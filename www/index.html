<!DOCTYPE html>

<html lang="en">

<style type="text/css">
    html, body {
        overflow: hidden;
        margin:0;
    }
</style>

<head>
    <meta charset="utf-8">

    <title>World War Paint</title>
    <meta name="description" content="worldwarpaint">
    <meta name="author" content="lukeandjosh">
    <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' />
    <!--  <link rel="stylesheet" href="css/styles.css?v=1.0">-->


</head>

<body>
   <!-- vertex shader -->
    <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_outputRects;
    attribute vec2 a_inputRects;
    attribute vec4 a_colors;

    uniform float u_flipY; //flip along y axis or not
    uniform vec2 u_inResolution; //resolution
    uniform vec2 u_outResolution; //resolution

    varying vec2 v_inputCoord;
    varying vec2 v_outputCoord;
    varying vec4 v_color;
    

    void main() {
       // convert the rectangle from pixels to 0.0 to 1.0
       vec2 inputZeroToOne = a_inputRects / u_inResolution;
       vec2 outputZeroToOne = a_outputRects / u_outResolution;

       // convert from 0->1 to 0->2
       vec2 zeroToTwo = outputZeroToOne * 2.0;

       // convert from 0->2 to -1->+1 (clipspace)
       vec2 clipSpace = zeroToTwo - 1.0;

       gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);

       // pass the texCoord to the fragment shader
       // The GPU will interpolate this value between points.
       v_inputCoord = inputZeroToOne;
       v_outputCoord = outputZeroToOne;
       
       v_color = a_colors;
    }
    </script>
    <!-- fragment shader -->
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // our 2 canvases
        uniform sampler2D u_canvasBuff;
        uniform sampler2D u_canvasDest;
        uniform bool u_fgDrawFromBuffer;

        // the texCoords passed in from the vertex shader.
        // note: we're only using 1 set of texCoords which means
        //   we're assuming the canvases are the same size.
        varying vec2 v_inputCoord;
        varying vec2 v_outputCoord;
        varying vec4 v_color;

        void main() {
             // Look up the pixels from buff and dest canvases
             vec4 colorBuff = texture2D(u_canvasBuff, v_inputCoord);
             vec4 colorDest = texture2D(u_canvasDest, v_outputCoord);

             if(u_fgDrawFromBuffer){
             
                if(colorBuff.rgb != vec3(0.0,0.0,0.0)){
                    gl_FragColor = colorDest;//default value
                    if(colorDest.a <= 0.0){
                        gl_FragColor = vec4(v_color.rgb, 0.1);
                    }else if(colorDest.a <= 0.8){
                        if(v_color.rgb == colorDest.rgb){
                            gl_FragColor = vec4(v_color.rgb,colorDest.a + 0.1);
                            if(gl_FragColor.a > 0.8) {
                                gl_FragColor = vec4(gl_FragColor.rgb, 0.8);
                            }
                        } else {
                            gl_FragColor = vec4(colorDest.rgb,colorDest.a - 0.1);
                        }
                    } else {
                        gl_FragColor = vec4(v_color.rgb,0.8);
                    }
                } else {
                    gl_FragColor = colorDest;
                }
             }
             else{
                //todo, gausian blur code goes here eventually.
                gl_FragColor =  colorDest;
             }
        }
    </script>
    <script id="histogram-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // our 2 canvases
        uniform sampler2D u_textureIn;
        uniform bool u_initialInput;
        uniform vec2 u_resolutionIn;
        
        uniform vec3 playerClrs[4];

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
            vec4 colorOut = vec4(0,0,0,0);
            
            if(u_initialInput){
                for(int x=0; x<4; x++){
                    for(int y=0; y<4; y++){
                        vec2 currentPixel = vec2(x,y) / u_resolution;
                        vec4 colorIn = texture2D(u_textureIn, (v_texCoord*4) + currentPixel); // Look up the pixels input texture
                        colorOut += getPixelIncrementation(colorIn);
                    }
                }
            }
            else{
                for(int x=0; x<4; x++){
                    for(int y=0; y<4; y++){
                        vec2 currentPixel = vec2(x,y) / u_resolution;
                        vec4 colorIn = texture2D(u_textureIn, (v_texCoord*4) + currentPixel); // Look up the pixels input texture
                        colorOut += colorIn * 0.0625; // 0.0625 = 1/16 but multiply is faster than divide
                    }
                }
            }

            gl_FragColor = colorOut;
        }
        
        vec4 getPixelIncrementation(vec4 colorIn){
            vec4 toReturn = vec4(0,0,0,0);
            for(int i=0; i<4; i++){
                if(playerClrs[i] == colorIn.rgb){
                    toReturn[i] = colorIn.a * 0.0625; // 0.0625 = 1/16 but multiply is faster than divide
                }
            }
            return toReturn;
        }
    </script>
    
    <script src="js/libs/jquery-2.1.4.js"></script>
    <script src="js/utility.js"></script>
    <script src="js/libs/webgl-utils.js"></script>
    <script src="js/libs/victor.min.js"></script>
    <script src="js/libs/phaser.js"></script>
    <script src="js/player.js"></script>
    <script src="js/gameBoardLayer.js"></script>
    <script src="js/gameServer.js"></script>
    <script src="js/main.js"></script>
    <script src="js/towerButton.js"></script>
    <script src="js/tower.js"></script>
    <div id="phaser_container"></div>
    <div id="backbuffer" style="display: none;">
        <canvas id="gameboard_canvas" style="border: none;" width="2048" height="2048"></canvas>
    </div>
</body>
</html>